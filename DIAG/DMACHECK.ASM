
	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

	.nolist

	include dmagsp.inc
	include dmasys.inc
	include	dmamacro.hdr

        include syscheck.set
        include syscheck.gbl

        include utilitie.mac
        include layout.mac

	.list

        .GLOBL  DMACHECK

        .BSS    FRAMEPTR, 32
	.BSS	EOSCRN,8    
	
	.text

IMAGE_START      .SET 2000000H
IMAGE_HEIGHT     .SET 10H            ; (IN PIXELS)
IMAGE_WIDTH      .SET 10H            ; (IN PIXELS)  -> MOD (WIDTH, 4) = 0

IMAGE_DIMENSIONS .SET [IMAGE_HEIGHT, IMAGE_WIDTH]
IMAGE_SCREEN_POS .SET [410,240]		;dma test off screen

; =====================================================

* BEGINNING OF PROGRAM

DMACHECK:

        MOVE SP, @FRAMEPTR, 1           ; BREAK ON ERROR

;Set pixel size to equate value
	movk	PXSIZE,A0
	move	A0,@PSIZE

;Set up OFFSET register
	movi	OFFSETVAL,OFFSET

;Set plane mask to equate value
	movi	PLANEMSK,A0
	move	A0,@PMASK

;Set background color
	CLR     COLOR0

;Set CONVSP, CONVDP AND PITCH
	movi	SCRN_PTCH,A0		;Get Screen Pitch
	move	a0,SPTCH
	move	a0,DPTCH
	lmo	A0,A0			;Convert in temporary register
	move	A0,@CONVSP		;Move to CONVSP io register
	move	A0,@CONVDP		;Move to CONVDP io register

;Set up CONTROL register
	movi	INI_CTRL,A0		; T=0,V=0,H=0
	move	A0,@CONTROL

;Set Up Display Interrupt
	movi		427,a0		;1ST INT AT HALF SCREEN
	move		a0,@dpyint
	movi		DIE,a0
	move		a0,@intenb	;ENABLE THE DISPLAY INTERRUPTS
	movi		0fffffea0h,a0	;INTERRUPT VECTOR
	movi		dirq,a1,L
	move		a1,*a0,1	;STORE THE ROUTINE LOCATION

BEGIN:
	CLR	A0
	MOVB	A0,@CMAPSEL	;RESET TO COLOR MAP 0
	MOVB	A0,@EOSCRN
	EINT

*	NORMAL IMAGE

	CLR	A1
	MOVK	DMAWNZ,DMACTL

	MOVI	IMAGE_START,      A14           ; LEFT CORNER
	MOVI	IMAGE_DIMENSIONS, DMASIZ, L

	MOVE	A14,DMASAD
	CALLR	HORIZFIX
	MOVI	IMAGE_SCREEN_POS, DMAXY	

	MOVI	40h,A6
	CALLR	CLIPX 			;CLIP FROM BOTH SIDES

*	FLIP ABOUT Y

	CALLR	SPLITSEC

	CLR	A1

        MOVI    PXSIZE*(IMAGE_WIDTH-1), A14     ; RIGHT CORNER
        ADDI    IMAGE_START, A14
	MOVE	A14,DMASAD	

	MOVI	IMAGE_DIMENSIONS, DMASIZ, L
	MOVI	IMAGE_SCREEN_POS, DMAXY, L

	MOVK	12h,DMACTL
	MOVI    ((2*IMAGE_WIDTH)-1), A0, L
        SLL     16,A0
	MOVY	A0,DMACTL
	CALLR	MHSCOMP			;DO THE OPERATION

	MOVI	40h,A6
	CALLR	CLIPY			;CLIP FROM BOTH SIDES

*	FLIP ABOUT X

	CALLR	SPLITSEC

        MOVI    PXSIZE*((IMAGE_HEIGHT-1)*IMAGE_WIDTH), A14, L   ; BOTTOM LEFT CORNER
        ADDI    IMAGE_START, A14
	MOVE	A14, DMASAD

	MOVI	IMAGE_DIMENSIONS, DMASIZ, L

;       =================================
;       | ASSUMING MOD (WIDTH,4) = 0 SO |
;       | HS = TS.                      |
;       =================================

	MOVI	22h,DMACTL
	MOVI	(2*IMAGE_WIDTH), A0, L	;CALCULATE THE OFFSET
	NEG	A0                	;OF = -(HS + TS)
	SLL	16,A0
	MOVY	A0,DMACTL
	CALLR	MHSCOMP

	MOVI	40h,A6
	CALLR	CLIPX

*	FLIP ABOUT X & Y

	CALLR	SPLITSEC

        MOVI    PXSIZE*((IMAGE_HEIGHT*IMAGE_WIDTH)-1), A14, L   ; BOTTOM RIGHT CORNER
        ADDI    IMAGE_START, A14
	MOVE	A14, DMASAD

	MOVI	IMAGE_DIMENSIONS, DMASIZ, L

;       =================================
;       | ASSUMING MOD (WIDTH,4) = 0 SO |
;       | HS = TS.                      |
;       =================================

	MOVI	32h,DMACTL
	MOVI	-1,A0           	;OF = (HS - TS) - 1
	SLL	16,A0
	MOVY	A0,DMACTL
	CALLR	MHSCOMP

	MOVI	40h,A6
	CALLR	CLIPY

BREAK:  DINT

        MOVI P_MAX, A14
        MOVE A14, @CONTROL

        MOVI DMA_CHIP, A14, L
        R_XYADR A14, A0
        R_DIMEN A14, A1
        MOVI (GREEN* 256) + GREEN, A2

        FCALL RECTANGLE, B6
        MOVI  100000H,   A14, L

DISP_GREEN:

        FCALL ADV_BUTTON, B6
        JRC   HURRY1
        DSJS  A14, DISP_GREEN

HURRY1:

        CLR  A14
        MOVE A14, @CONTROL

        MOVE @FRAMEPTR, SP, 1
	RETS

*	CLIP ON BOTH SIDES ON A FLIP ABOUT Y
*	A6	--> ITERATION COUNT
	
CLIPY:
	MOVE	A0,-*SP,1
CLIPY1

	CLR	A0
	DEC	DMASIZ
	CMPXY	A0,DMASIZ
	JRXEQ	CLIPYX
	SUBI	10000h,DMACTL
	CALLR	MV4
	DEC	DMASIZ
	CMPXY	A0,DMASIZ
	JRXEQ	CLIPYX
	SUBI	10000h,DMACTL
	SUBK	8,DMASAD
	CALLR	MV4
	DSJ	A6,CLIPY1
CLIPYX
	MOVE	*SP+,A0,1
	RETS

*	CLIP ON BOTH SIDES ON A FLIP ABOUT X
*	A6  	--> ITERATION COUNT

CLIPX:
	MOVE	A0,-*SP,1
CLIPX1

	CLR	A0
	DEC	DMASIZ
	CMPXY	A0,DMASIZ
	JRXEQ	CLIPXX
	ADDI	10000h,DMACTL
	CALLR	MV4
	DEC	DMASIZ
	CMPXY	A0,DMASIZ
	JRXEQ	CLIPXX
	ADDI	10000h,DMACTL
	ADDK	8,DMASAD
	CALLR	MV4
	DSJ	A6,CLIPX1
CLIPXX
	MOVE	*SP+,A0,1
	RETS

*	MOVE FOUR PIXELS IN THE X DIRECTION DISPLAYING IN EACH POSITION

MV4	MOVE	A0,-*SP,1
	MOVI	244,A0
MVAN
 	CALLR	SPLITSEC
	CALLR	DSCOMP
	INC	DMAXY
	CMPXY	A0,DMAXY
	JRXLT	MVAN
	MOVI	IMAGE_SCREEN_POS,DMAXY
	MOVE	*SP+,A0,1
	RETS

*	DMA --> SIMULATE --> COMPARE

DSCOMP	CALLR	MANDMA
	CALLR	DMASIM
	JRUC	PIXCOMP

*	MANUAL DMA --> HORIZ. FIX --> SIMULATE --> COMPARE

MHSCOMP:
	CALLR	MANDMA
	JRUC	HSFIX

*	DMA --> HORIZONTAL FIX -> SIMULATE --> COMPARE

DHSCOMP:
	CALLR	DTIME
HSFIX	CALLR	HORIZFIX
	CALLR	DMASIM
	JRUC	PIXCOMP

*	MAKE THE HORIZ. SIZE THE NEXT DIVISIBLE BY 4 NUMBER
*	DMASIZ(A5) HAS THE HSIZE IN THE LOWER WORD.

HORIZFIX:
	ADDK	3,DMASIZ
	SRL	2,DMASIZ
	SLL	2,DMASIZ
	RETS

*	SIMULATE A DMA OPERATION.

*	REGISTER	HIGH WORD	LOW WORD
*	--------	---------	--------
*	   A1		CNST. COL.	X-LATION
*	   A2		VERT. SIZE	HORZ. SIZE
*	   A3		VERT. ADDR	HORZ. ADDR
*	   A4		SAG UPPER	SAG LOWER
*	   A5		OFFSET		CONTROL

DMASIM:
	MOVE	DMASAD,SADDR		;SET THE STARTING ADDRESS
	CALLR	GETSPTCH		;SET THE SOURCE PITCH, CLIPPING
	CALLR	GETDADDR		;SET THE SCREEN ADDRESS
	CVXYL	DADDR,B10		;MAKE IT LINEAR AND SAVE A COPY
	MOVE	B10,DADDR
	MOVI	1000h,DPTCH		;SET THE SCREEN PITCH
	MOVE	DMASIZ,DYDX		;SET THE DIMENSIONS OF THE BLOCK
	CALLR	DMAWT
	MOVY	DYDX,B11
	SRL	16,B11
NLINE:
	CLR	B12
	MOVX	DYDX,B12
NPIX:
	MOVB	*SADDR,B13	
	CALLR	PIXOP			;DO THE PIXEL OPERATION
	JRC	WIPIX			;BR = WRITE INHIBIT
	MOVB	B13,*DADDR		;OTHERWISE CHANGE IT
	
WIPIX	BTST	4,DMACTL
	JREQ	CFLIPX			;BR = EITHER FLIPPING X OR NOTHING
	ADDK	8,DADDR
	DEC	B12
	JREQ	ADDOFF	 		;SPECIAL PREDECREMENT, IT DOESN'T
	SUBK	8,SADDR			;OCCUR ON THE LAST PIXEL(DMA FUCK)
	JRUC	NPIX

CFLIPX	BTST	5,DMACTL
	JREQ	NORMDW
	ADDK	8,DADDR
	DEC	B12
	JREQ	ADDOFF
	ADDK	8,SADDR
	JRUC	NPIX

NORMDW	ADDK	8,SADDR
	ADDK	8,DADDR
	DSJ	B12,NPIX

ADDOFF	BTST	5,DMACTL
	JREQ	NORMAD
	SUB	SPTCH,SADDR
	JRUC	MVDAD
NORMAD	ADD	SPTCH,SADDR
MVDAD	MOVE	B10,DADDR
	ADD	DPTCH,DADDR
	MOVE	DADDR,B10
	DSJ	B11,NLINE
	RETS

*	GET THE DESTINATION ADDRESS

GETDADDR:
	MMTM	SP,A14
	CALLR	GETTS
	MOVE	DMAXY,A13
	ADDK	5,A14
	SUBXY	A14,A13
	MOVE	A13,DADDR
	MMFM	SP,A14
	RETS

*	GET THE SOURCE PITCH(THIS IS ACTUALLY THE OFFSET * 8)

GETSPTCH:
	MMTM	SP,A14
	CLR	A14
	MOVY	DMACTL,A14	;GET THE OFFSET
	BTST	5,DMACTL
	JREQ	NOXF
	NEG	A14  		;GET THE POSITIVE NUMBER BACK
    	SRL	16,A14		;SLIDE IT DOWN
	BTST	4,DMACTL
	JRNE	ONLYX		;DON'T WORRY ABOUT THE Y DIRECTION
	DEC	A14		;COMPENSATE FOR THE LOFFREDO "CARRY"
ONLYX	SLL	3,A14		;MULTIPLY BY 8
	JRUC	MVSP

NOXF	SRL	13,A14		;SHIFT INTO THE LOW HALF, * 8
MVSP	MOVE	A14,SPTCH	;AND PUT IT IN THE SOURCE PITCH REG.
	MMFM	SP,A14
	RETS

*	GET THE TOTAL SIZE;	RETURNS TS IN A14

GETTS:	MMTM	SP,A0,A13
	CLR	A0
	MOVE	DMASIZ,A13	;A13 -> CURRENT HORIZ. SIZE
	MOVE	DMACTL,A14	;A14 -> OFFSET
	MOVY	A0,A13
	SRL	16,A14
	BTST	4,DMACTL	;FLIP ABOUT Y?
	JREQ	XCHK		;BR = NO
	BTST	5,DMACTL	;FLIP ABOUT BOTH
	JRNE	DOXY		;BR = YES

	INC	A14		;IN THIS CASE ->   TS = (OF + 1) - HS
	SUB	A13,A14
	JRUC	TSITIS

XCHK	BTST	5,DMACTL	;FLIP ABOUT X?
	JREQ	NORMTS		;BR = NO
	NEG	A14		;IN THIS CASE ->   TS = -OF + 1 - HS
	MOVY	A0,A14
	INC	A14
	SUB	A13,A14
	JRUC	TSITIS

DOXY	NEG	A14		;IN THIS CASE ->   TS = -OF - 1 + HS
	MOVY	A0,A14
	DEC	A14
	ADD	A13,A14
	JRUC	TSITIS
	
NORMTS	ADD	A13,A14		;OTHERWISE ->      TS = OF + HS
TSITIS	MMFM	SP,A0,A13
	RETS

*	DO THE PIXEL OPERATION
*	BIT 0  - DRAW ZERO DATA
*	BIT 1  - DRAW NON-ZERO DATA
*	BIT 2  - DRAW CONSTANT ON ZERO DATA
*	BIT 3  - DRAW CONSTANT ON NON-ZERO DATA

PIXOP	CMPI	0,B13
	JRNE	NZPIX		;BR = NON-ZERO DATA
	BTST	0,DMACTL
	JRNE	PIXGO		;BR = DRAW ZERO DATA
	BTST	2,DMACTL
	JRNE	SUBCON		;BR = SUBSTITUE THE CONSTANT
	JRUC	POPSET		;OTHERWISE SET THE CARRY
NZPIX	BTST	1,DMACTL
	JRNE	PIXGO		;BR = DRAW NON-ZERO DATA
	BTST	3,DMACTL
	JRNE	SUBCON		;BR = SUBSTITUTE THE CONSTANT
POPSET	SETC
	JRUC	PIXD		;NO SANK YOU FOR DATA TODAY
SUBCON	MOVE	DMACON,B13	;GET THE DMA CONSTANT
	SRL	16,B13		;SLIDE IT DOWN
PIXGO	CLRC			;WRITE THAT DATA
PIXD	RETS

*	DO A COMPARISON BETWEEN THE DMA AND MY BLOCK CONVERSION.
*	THIS THING WORKS ON MORSEL(4 BYTE) CHUNKS
PIXCOMP:
	MMTM	SP,A0,A6,A8,A9,A10,A11,A12,A13,A14
	MOVE	DMASIZ,A11
	CLR	A10
	MOVX	A11,A10			;A10 -> HORIZ. SIZE
****	SRL	2,A10			;DIVIDE BY FOUR
	SRL	16,A11			;A11 -> VERT. SIZE
	CLR	A0			;START AT THE FIRST LINE
NEWLN	MOVE	A10,A6			;A6 IS THE HORIZ. COUNTER
	CALLR	INCSCRAD
NXTPIX	MOVB	*A14,A9
	MOVB	*A12,A8			;GET THE PIXEL DATA
	CMP	A9,A8			;COMPARE THEM
	JRNE	PIXFAIL	 		;BR = FAILURE
	ADDK	8,A14
	ADDK	8,A12
	DSJ	A6,NXTPIX		;DO A NEW PIX
	INC	A0
	CMP	A0,A11			;DONE WITH PICTURE?
	JREQ	PIXDONE			;BR = YES
	JRUC	NEWLN			;DO ANOTHER LINE

PIXFAIL	DINT

        MOVI P_MAX, A14
        MOVE A14, @CONTROL

        MOVI DMA_CHIP, A14, L
        R_XYADR A14, A0
        R_DIMEN A14, A1
        MOVI (RED* 256) + RED, A2

        FCALL RECTANGLE, B6
        MOVI  100000H,   A14, L

DISP_RED:

        FCALL ADV_BUTTON, B6
        JRC   HURRY2
        DSJS  A14, DISP_RED

HURRY2:

        CLR  A14
        MOVE A14, @CONTROL

        MOVE @FRAMEPTR, SP, 1
        RETS

PIXDONE	MMFM	SP,A0,A6,A8,A9,A10,A11,A12,A13,A14
	RETS				;AND RETURN

*	GET THE SCREEN ADDRESSES OF THE DMA DATA(A14) AND THE
*		TEST BLOCK DATA(A12)

GETSCRAD:
	CALLR	GETDADDR
	CVXYL	DMAXY,A14		;A14 -> DMA SCREEN ADDRESS
	CVXYL	A13,A12			;A12 -> TEST BLOCK SCREEN ADDRESS
	RETS

*	SET THE SCREEN ADDRESS TO THE NEXT LINE, A0 -> CURRENT LINE.

INCSCRAD:
	MMTM	SP,A0
	CALLR	GETSCRAD
NXTLN	CMPI	0,A0
	JREQ	NEWSAD
	ADDI	1000h,A14
	ADDI	1000h,A12		;NEXT LINE
	DEC	A0
	JRUC	NXTLN
NEWSAD	MMFM	SP,A0
	RETS

*	END OF SCREEN INTERRUPT ROUTINE

dirq:
	MMTM	SP,A0

	move		@intpend,A0
	andni	DIE,A0
	move		A0,@intpend

	MOVB	@EOSCRN,A0
	JREQ	EOI
	DEC	A0
	MOVB	A0,@EOSCRN
EOI:
	MMFM	SP,A0
	reti

*	WAIT ON THE INTERRUPT TO COUNT DOWN 1 SECOND

ONEFRAME:
	MMTM	SP,A0
	MOVK	1,A0
	JRUC	BTOEOS

SPLITSEC:
	MMTM	SP,A0
	MOVK	3,A0
	JRUC	BTOEOS

ONESEC	MMTM	SP,A0
	MOVK	5,A0
BTOEOS	MOVB	A0,@EOSCRN

MORSEC	MOVB	@EOSCRN,A0
	JREQ	NOSEC
	JRUC	MORSEC

NOSEC
	CALLR	CLRINVIS		;CLEAR BOTTOM PART OF SCREEN

        FCALL   ADV_BUTTON, B6
        JRC     BREAK

	MMFM	SP,A0
	RETS

CLRINVIS
;Clear screen
        MOVI    [400,0], DADDR, L
        MOVI    [100,512], DYDX,  L

        MOVI    SCRN_PTCH, DPTCH
        LMO     DPTCH, B10
        MOVE    B10, @CONVDP

        CLR     OFFSET
        CLR     COLOR1
        FILL    XY
	RETS

*	DTIME - USED TO DMA AN IMAGE
*		A1  - MSW = CONSTANT COLOR;   LSW = ZERO(FOR NOW)
*		A3  - MSW = VERTICAL ADDRESS; LSW = HORIZONTAL ADDRESS
*		A5  - MSW = OFFSET REGISTER;  LSW = CONTROL BYTE
*		A14 - ADDRESS OF IMAGE DATA

DTIME:
	MMTM	SP,A0,A13,A14
	MOVI	01A800A0h,A13
	CALLR	DMAWT
	MOVE	*A14+,A2,1
DTSNK:	MOVE	A14,A4
	MMTM	A13,A1,A2,A3,A4

	MOVY	A5,A0
	SRL	16,A0
	MOVE	A0,@DMAOFFST,0
	ORI	8000H,A5
	MOVE	A5,@DMAGO

	MMFM	SP,A0,A13,A14
	RETS

*	USE THIS ROUTINE IF YOU STUFF THE HSIZE AND VSIZE MANUALLY

MANDMA:
	MMTM	SP,A0,A13
	MOVI	DMAREGS, A13, L
	CALLR	DMAWT
	MMTM	A13,A1,A2,A3,A4

	MOVY	A5,A0
	SRL	16,A0
	MOVE	A0,@DMAOFFST
	ORI	8000H, A5
	MOVE	A5, @DMAGO

	MMFM	SP,A0,A13
	RETS

*********************************************************
******* WAIT ON THE DMA *********************************
*********************************************************

DMAWT:	MMTM	SP,A0
DMANR:	MOVE	@DMAGO,A0
	BTST	15,A0
	JRNZ	DMANR

	MMFM	SP,A0
	RETS


************  CLEAR SCREEN ROUTINE  *********************

clr_scrn:
	move		@convdp,b12
	MOVE		@DPYCTL,b13,0		;Copy display control reg.
	mmtm		sp,b13,b12,offset,dptch,color1
	move		b13,a13
	movi		SCRN_PTCH*2,b12 	;Get Screen Pitch
	move		b12,DPTCH
	lmo		b12,b12 			;Convert in temporary re
	move		b12,@CONVDP		;Move to CONVDP io register
	clr		COLOR1		     ;Set B9 = black
* Clear portion of frame buffer corresponding to scan lines #0 and 1.
	 CLR		OFFSET		     ;Origin at start of memory
	 CLR		DADDR		     ;Set B2 = (0,0)
	 MOVI	(1024*X)+(1*Y),DYDX	;Set B7 = (1024,1)
	 FILL	XY				;Set 1st line to colorval
* Set SRT=1.  This converts pixel accesses to VRAM SR transfer cycles.
	 ANDNI	  SRE+ENV,a13	     ;Turn off screen refresh
	 ORI	       SRT,a13		     ;Enable SR transfers
	 MOVE	  a13,@DPYCTL,0 	;Load new display control
	 MOVE	  @DPYCTL,a13,0 	;Read back to be safe!
* Load frame buffer for 1st line into VRAM shift registers.
	 CLR		  DADDR 		;Set B2 = (0,0) again
	 PIXT	  *DADDR.XY,DADDR	;Load VRAM shift registers
* Transfer contents of VRAM shift registers to rest of frame buffer.
	 MOVI	  (0*X)+(1*Y),DADDR	     ;Set B2 = (0,1)
	 MOVI	  (4*X)+(255*Y),DYDX	;Set B7 = (4,255)
	 FILL	  XY			   ;255 SR-to-memory transfers
* Restore previous contents of registers.

	mmfm		sp,b13,b12,offset,color1,dptch
	move		b12,@convdp
     MOVE		b13,@DPYCTL,0		;Copy display control reg.
	rets

	.end


